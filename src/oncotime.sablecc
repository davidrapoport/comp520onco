Package oncotime;

Helpers
	a = ['a' + 'A'];
	b = ['b' + 'B'];
	c = ['c' + 'C'];
	d = ['d' + 'D'];
	e = ['e' + 'E'];
	f = ['f' + 'F'];
	g = ['g' + 'G'];
	h = ['h' + 'H'];
	i = ['i' + 'I'];
	j = ['j' + 'J'];
	k = ['k' + 'K'];
	l = ['l' + 'L'];
	m = ['m' + 'M'];
	n = ['n' + 'N'];
	o = ['o' + 'O'];
	p = ['p' + 'P'];
	q = ['q' + 'Q'];
	r = ['r' + 'R'];
	s = ['s' + 'S'];
	t = ['t' + 'T'];
	u = ['u' + 'U'];
	v = ['v' + 'V'];
	w = ['w' + 'W'];
	x = ['x' + 'X'];
	y = ['y' + 'Y'];
	z = ['z' + 'Z'];

	space_key = ' ';
	punc = '.' | '!' | '?' | '_' ;
	left_angle = '<';
	right_angle = '>';
	lower_letter  = ['a'..'z'];
	upper_letter = ['A'..'Z'];
	upper_or_lower = upper_letter | lower_letter;
	letter = lower_letter | upper_letter | punc;
	cr = 13;
	lf = 10;
	tab = 9;
	eol = cr | lf;
	whitespace = 13 | 10 | 9 | ' ';
	not_eol = [[0..0xff] - [cr + lf]];
	all = [0..0xff];
	comment_text = [all - ['*' + '/']];
	letter_or_whitespace = letter | whitespace;

	non_zero_digit = ['1'..'9'];
	zero = '0';
	digit = zero | non_zero_digit;
  	digits = digit+;

  	/* Found in reference compiler grammar */
  	male = 'male' | 'm' | 'Male' | 'M' ; 
  	female = 'female' | 'f' | 'Female' | 'F';
	
	open_multiline = '/*';
	close_multiline = '*/';

Tokens
	comma = ',';
	colon = ':';
	assign = '=';
	use_keyword = u s e;
	group_keyword = g r o u p;
	script_keyword = s c r i p t;
	to = 'to';
	multiline_comment = open_multiline ('*' comment_text* eol?)* close_multiline;
	comment = '//'  not_eol*  eol;

	open_paren = '(';
	close_paren = ')';

	open_bracket = '{';
	close_bracket = '}';

	star = '*';
	dot = '.';

	//Computation keywords
	t_print = p r i n t;
	t_table = t a b l e;
	t_count = c o u n t;
	by = b y;
	t_foreach = f o r e a c h;
	t_not = n o t;
	in = i n;
	t_list = l i s t;
	t_sequences = s e q u e n c e s?;
	t_member = m e m b e r;
	arrow = '->';
	bar = '|';
	open_square = '[';
	close_square = ']';
	t_timeline = t i m e l i n e;
	of = o f;
	t_barchart = b a r c h a r t;
	t_length = '.' l e n g t h;
	t_element = e l e m e n t;
	t_native = n a t i v e;
	t_like = l i k e;


/* Filter Tokens */

/* Filter keywords */
    event_filter_header = (e v e n t s whitespace+ a r e) | (e v e n t whitespace+ i s);
	population = p o p u l a t i o n;
	period = p e r i o d;
	event = e v e n t s?;
	doctor = d o c t o r s?;
	is = i s;
	are = a r e;

/* Population */
	id = i d;
	gender = s e x;
	birthyear = b i r t h y e a r;
	diagnosis = d i a g n o s i s;
	postalcode = p o s t a l c o d e;
	either_gender = male | female;

/* Period */
	years = y e a r s?;
	months = m o n t h s;
	days =  d a y s?;
	hours = h o u r s?;
	start = s t a r t;
	end = e n d;

/* Other Types */
	patient = p a t i e n t s?;
	date = d a t e s;


	t_postalcode = upper_or_lower digit upper_or_lower digit upper_or_lower digit | 
	  				upper_or_lower digit upper_or_lower;
	identifier_expansion = '<' whitespace* (upper_or_lower (digit | letter)*) whitespace* '>';
	group_file = upper_or_lower (digit | letter)* '.grp';
	identifier = upper_or_lower (letter | digit)*;
	quoted_string = '"' letter_or_whitespace+ '"';
	
	space = space_key;
	blank = (tab);
	eol = eol;
	newline   = cr | lf | cr lf;
	integer_literal = digits;

Ignored Tokens
	space, blank, comment, eol;

Productions
	program = {script} script_header use_clauses* groups_definitions* filters* open_bracket computation* close_bracket| 
	          {group_file} multiline_comment groups_definitions*;

	script_header = script_keyword identifier script_params_list multiline_comment;
	script_params_list = open_paren param_list? close_paren;

	param_list = identifier param_list_tail*;
	param_list_tail = comma identifier;

	use_clauses = use_keyword use_files_list;
	use_files_list = group_file use_files_tail*;
	use_files_tail = comma group_file;

	groups_definitions = group_keyword filter_type identifier assign open_bracket value_list? close_bracket;

	filters = {pop_filter} pop_filter | {period_filter} period_filter 
			| {event_filter} event_filter | {doctor_filter} doctor_filter;

	filter_type = {population_types} population_type | 
	              {period_types} period_type |
	              {doctor_types} doctor_type |
	              {event_types} event_type ;


	filter_type_list = filter_type filter_type_list_tail*;
	filter_type_list_tail = comma filter_type;

	population_type =  {patientid} id | {gender} gender | 
		{birthyear} birthyear |
		{diagnosis} diagnosis  |
		{postalcode} postalcode ;

	period_type = {year} years |{month} months |{day} days |
	              {hour} hours |{start} start |{end} end ;
	doctor_type = doctor;
	event_type = event;

	pop_filter = population is pop_field+;
	pop_field = population_type colon value_list;

	period_filter = period is period_field+;
	period_field = period_type colon value_list;

	doctor_filter = doctor are doctor_field+;
	doctor_field = id colon value_list;

	event_filter = event_filter_header event_field;
	event_field = event colon value_list;

	value_list = value value_list_tail*;
	value_list_tail = comma value;

	value =  {primitive} primitive_value |
			 {identifier_expansion} identifier_expansion |
			 {wildcard_val} star | 
	         {range_val} [start]:primitive_value to [end]:primitive_value ;
	
	primitive_value = {string_val} identifier |
	         {quoted_string_val} quoted_string |
	         {number_val} integer_literal |
	         {gender_val} either_gender |
	         {postalcode_val} t_postalcode;

	identifier_list = {idnt} identifier ident_list_tail* | {idnt_exp} identifier_expansion ident_list_tail*;
	ident_list_tail = {idnt} comma identifier | {idnt_exp} comma identifier_expansion;


	actor = {doc} doctor | {patient} patient | {diagnosis} diagnosis ;

	computation = {foreach_single} t_foreach foreach_clause computation |
				  {foreach_multi}  t_foreach foreach_clause open_bracket computation+ close_bracket|
				  {print} t_print print_value |
				  {table} t_table identifier assign table_value|
				  {barchart} t_barchart identifier |
				  {list_def} t_list identifier assign t_sequences t_like sequence_def;
				  

	foreach_clause = {by_type} actor identifier | 
	                 {member} t_member [variable]:identifier in [sequence]:identifier|
	                 {element} t_element [variable]:identifier of [table]:identifier|
	                 {sequence_in_list} t_sequences identifier t_like sequence_def;
	                 

	print_value = {value} identifier | {attributes} filter_type_list of identifier|
	              {timeline} t_timeline of identifier|
	              {index} [variable]:identifier open_square [index_v]:identifier close_square |
	              {table_val} table_value|
	              {length} identifier dot t_length;

	table_value = {count} t_count actor by filter_type|
	              {native} t_native open_paren param_list? close_paren;

	sequence_def = open_square sequence_stmt? close_square;
	sequence_stmt = sequence_unit  sequence_stmt_tail*;
	sequence_stmt_tail = {bar} bar sequence_unit|
	                     {arrow} arrow sequence_unit;

	sequence_unit = {idnt} identifier | {idnt_exp} identifier_expansion |
	                {list} open_bracket identifier_list close_bracket |
	                {negation} open_paren t_not identifier_list close_paren |
	                {end} end |
	                {start} start;
